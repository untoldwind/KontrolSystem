use * from ksp::testing
use { Vec2, vec2, Vec3, vec3, euler } from ksp::math

test sync fn test_vector2() -> Unit = {
    let a : Vec2 = vec2(1.0, 2.0)
    let b : Vec2 = vec2(4.0, 5.0)

    assert_float(1.0, a.x, 1e-10)
    assert_float(2.0, a.y, 1e-10)

    assert_float(5.0, (a + b).x, 1e-10)
    assert_float(7.0, (a + b).y, 1e-10)

    assert_vec2(vec2(-1.0, -2.0), -a, 1e-10)
    assert_vec2(vec2(5.0, 7.0), a + b, 1e-10)
    assert_vec2(vec2(3.0, 3.0), b - a, 1e-10)
    assert_vec2(vec2(3.0, 6.0), a * 3.0, 1e-10)
    assert_vec2(vec2(4.0, 8.0), 4.0 * a, 1e-10)
    assert_vec2(vec2(0.5, 1.0), a / 2.0, 1e-10)

    assert_true(vec2(5.0, 7.0) == a + b)
    assert_false(vec2(6.0, 7.0) == a + b)
    assert_false(vec2(5.0, 7.0) != a + b)
    assert_true(vec2(6.0, 7.0) != a + b)

    assert_float(5.0, vec2(3.0, 4.0).magnitude, 1e-10)
    assert_float(25.0, vec2(3.0, 4.0).sqrMagnitude, 1e-10)

    let n = b.normalized

    assert_float(1.0, n.magnitude, 1e-10)
}

test sync fn test_vector2_methods() -> Unit = {
    assert_float(45, vec2(1.0, 0.0).angle_to(vec2(1, 1)), 1e-10)
}

test sync fn test_vector2_assign_op() -> Unit = {
    let a = vec2(1, 2)

    assert_vec2(vec2(1.0, 2.0), a, 1e-10)

    a += vec2(5,8)

    assert_vec2(vec2(6.0, 10.0), a, 1e-10)

    a -= vec2(3,4)

    assert_vec2(vec2(3.0, 6.0), a, 1e-10)

    a *= 0.5

    assert_vec2(vec2(1.5, 3.0), a, 1e-10)
}

test sync fn test_vector2_record() -> Unit = {
    const v1 : Vec2 = (x: 1.1, y: 2.2, something: "Not important")

    assert_vec2(vec2(1.1, 2.2), v1, 1e-10)
}

test sync fn test_vector3() -> Unit = {
    let a : Vec3 = vec3(1.0, 2.0, 3.0)
    let b : Vec3 = vec3(-7.0, 8.0, 9.0)

    assert_float(1.0, a.x, 1e-10)
    assert_float(2.0, a.y, 1e-10)
    assert_float(3.0, a.z, 1e-10)

    assert_float(-6.0, (a + b).x, 1e-10)
    assert_float(10.0, (a + b).y, 1e-10)
    assert_float(12.0, (a + b).z, 1e-10)

    assert_vec3(vec3(-1.0, -2.0, -3.0), -a, 1e-10)
    assert_vec3(vec3(-6.0, 10.0, 12.0), a + b, 1e-10)
    assert_vec3(vec3(-8.0, 6.0, 6.0), b - a, 1e-10)
    assert_vec3(vec3(3.0, 6.0, 9.0), a * 3.0, 1e-10)
    assert_vec3(vec3(4.0, 8.0, 12.0), 4.0 * a, 1e-10)
    assert_vec3(vec3(0.5, 1.0, 1.5), a / 2.0, 1e-10)

    assert_true(vec3(-6.0, 10.0, 12.0) == a + b)
    assert_false(vec3(-6.0, 10.0, 9.0) == a + b)
    assert_false(vec3(-6.0, 10.0, 12.0) != a + b)
    assert_true(vec3(-6.0, 10.0, 11.0) != a + b)

    assert_float(5.0, vec3(3.0, 4.0, 0.0).magnitude, 1e-10)
    assert_float(26.0, vec3(3.0, 4.0, 1.0).sqrMagnitude, 1e-10)

    let n = b.normalized

    assert_float(1.0, n.magnitude, 1e-10)

    assert_vec3(vec3(1.0, 3.0, 2.0), a.xzy, 1e-10)

    assert_vec3(vec3(-6.0, -30.0, 22.0), a.cross(b), 1e-10)

    assert_float(a.x * b.x + a.y * b.y + a.z * b.z, a.dot(b), 1e-10)
}

test sync fn test_vector3_methods() -> Unit = {
    assert_float(45, vec3(1.0, 0.0, 0.0).angle_to(vec3(1, 1, 0)), 1e-10)
}

test sync fn test_vector3_record() -> Unit = {
    const v1 : Vec3 = (x: 1.1, y: 2.2, z: 3.3, something: "Not important")

    assert_vec3(vec3(1.1, 2.2, 3.3), v1, 1e-10)

    let v2 = v1 & (y: 4.4, z: 5.5)

    assert_vec3(vec3(1.1, 2.2, 3.3), v1, 1e-10)
    assert_vec3(vec3(1.1, 4.4, 5.5), v2, 1e-10)

    v2 &= (x: -1.1, y: -2.2)

    assert_vec3(vec3(-1.1, -2.2, 5.5), v2, 1e-10)
}
