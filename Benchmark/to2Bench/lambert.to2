use { abs, sqrt, acos, asin, sin, sinh, log, pow, PI } from core::math
use { Vec3, vec3, acosh, asinh } from ksp::math

// This is based on the solver developed by Dario Izzo
// Details can be found here: https://arxiv.org/pdf/1403.2705.pdf
// Released under the GNU GENERAL PUBLIC LICENSE as part of the PyKEP library:

pub sync fn solve(r1 : Vec3, r2 : Vec3, tof : float, mu : float, clockwise : bool) -> Vec3 = {
    let c       = (r2 - r1).magnitude
    let R1      = r1.magnitude
    let R2      = r2.magnitude
    let s       = (c + R1 + R2) / 2.0
    let ir1     = r1.normalized
    let ir2     = r2.normalized
    let ih      = ir1.cross(ir2).normalized
    let lambda2 = 1.0 - c / s
    let lambda  = if (ih.z < 0.0) -sqrt(lambda2) else sqrt(lambda2)
    let it1     = if (ih.z < 0.0) ir1.cross(ih).normalized else ih.cross(ir1).normalized
    let it2     = if (ih.z < 0.0) ir2.cross(ih).normalized else ih.cross(ir2).normalized

    let lambda3 = lambda * lambda2
    let T       = sqrt(2.0 * mu / s / s / s) * tof

    // 2 - We now have lambda, T and we will find all x
    // 2.1 - Let us first detect the maximum number of revolutions for which there exists a solution
    let T0      = acos(lambda) + lambda * sqrt(1.0 - lambda2)
    let T1      = 2.0 / 3.0 * (1.0 - lambda3)

    // 3 - We may now find all solutions in x,y
    // 3.1 0 rev solution
    // 3.1.1 initial guess
    let tmp = if(T >= T0) -(T - T0) / (T - T0 + 4.0) else 
              if(T <= T1) T1 * (T1 - T) / (2.0 / 5.0 * (1.0 - lambda2 * lambda3) * T) + 1.0 else 
                          pow((T / T0), 0.69314718055994529 / log(T1 / T0)) - 1.0

    let (x, iters) = householder(lambda, T, tmp, 0, 1e-5, 15)

    let gamma = sqrt(mu * s / 2.0)
    let rho   = (R1 - R2) / c
    let sigma = sqrt(1.0 - rho * rho)
    let y     = sqrt(1.0 - lambda2 + lambda2 * x * x)
    let vr1   = gamma * ((lambda * y - x) - rho * (lambda * y + x)) / R1
    let vr2   = -gamma * ((lambda * y - x) + rho * (lambda * y + x)) / R2
    let vt    = gamma * sigma * (y + lambda * x)
    let vt1   = vt / R1
    let vt2   = vt / R2

    vr1 * ir1 + vt1 * it1 + vr2 * ir2 + vt2 * it2
}

sync fn householder(lambda : float, T : float, x0 : float, N : int, eps : float, iter_max : int) -> (float, int) = {
    let it   = 0
    let err  = 1.0
    let x    = x0

    while ((err > eps) && (it < iter_max)) {
        let tof = x2tof(lambda, x, N)
        let (DT, DDT, DDDT) = dTdx(lambda, x, tof)
        let delta = tof - T
        let DT2   = DT * DT
        let xnew  = x - delta * (DT2 - delta * DDT / 2.0) / (DT * (DT2 - delta * DDT) + DDDT * delta * delta / 6.0)
        err = abs(x - xnew)
        x = xnew
        it = it + 1
    }
    (x, it)
}

sync fn dTdx(lambda : float, x : float, T : float) -> (float, float, float) = {
    let l2   = lambda * lambda
    let l3   = l2 * lambda
    let umx2 = 1.0 - x * x
    let y    = sqrt(1.0 - l2 * umx2)
    let y2   = y * y
    let y3   = y2 * y
    
    let DT   = 1.0 / umx2 * (3.0 * T * x - 2.0 + 2.0 * l3 * x / y)
    let DDT  = 1.0 / umx2 * (3.0 * T + 5.0 * x * DT + 2.0 * (1.0 - l2) * l3 / y3)
    let DDDT = 1.0 / umx2 * (7.0 * x * DDT + 8.0 * DT - 6.0 * (1.0 - l2) * l2 * l3 * x / y3 / y2)

    (DT, DDT, DDDT)
}

sync fn x2tof(lambda : float, x: float, N : int) -> float = {
    let battin   = 0.01
    let lagrange = 0.2
    let dist     = abs(x - 1.0)

    if (dist < lagrange && dist > battin) {
        // We use Lagrange tof expression
        return x2tof2(lambda, x, N)
    }

    let K   = lambda * lambda
    let E   = x * x - 1.0
    let rho = abs(E)
    let z   = sqrt(1.0 + K * E)

    if (dist < battin) {
        // We use Battin series tof expression
        let eta = z - lambda * x
        let S1  = 0.5 * (1.0 - lambda - x * eta)
        let Q   = hypergeometricF(S1, 1e-11)
        Q = 4.0 / 3.0 * Q
        (eta * eta * eta * Q + 4.0 * lambda * eta) / 2.0 + N.to_float * PI / pow(rho, 1.5)
    } else {
        // We use Lancaster tof expresion
        let y = sqrt(rho)
        let g = x * z - lambda * E
        let d = 0.0
        if (E < 0.0) {
            let l = acos(g)
            d = N.to_float * PI + l
        } else {
            let f = y * (z - lambda * x)
            d = log(f + g)
        }
        (x - lambda * z - d / y) / E
    }
}

sync fn x2tof2(lambda : float, x: float, N : int) -> float = {
    let a = 1.0 / (1.0 - x * x)
    if (a > 0.0) { // ellipse
        let alfa = 2.0 * acos(x)
        let beta = 2.0 * asin(sqrt(lambda * lambda / a))
        if (lambda < 0.0) beta = -beta
        ((a * sqrt(a) * ((alfa - sin(alfa)) - (beta - sin(beta)) + 2.0 * PI * N.to_float)) / 2.0)
    } else {
        let alfa = 2.0 * acosh(x)
        let beta = 2.0 * asinh(sqrt(-lambda * lambda / a))
        if (lambda < 0.0) beta = -beta
        (-a * sqrt(-a) * ((beta - sinh(beta)) - (alfa - sinh(alfa))) / 2.0)
    }
}

sync fn hypergeometricF(z : float, tol : float) -> float = {
    let Sj  = 1.0
    let Cj  = 1.0
    let err = 1.0
    let j   = 0.0

    while (err > tol) {
        let Cj1 = Cj * (3.0 + j) * (1.0 + j) / (2.5 + j) * z / (j + 1.0)
        let Sj1 = Sj + Cj1
        err = abs(Cj1)
        Sj = Sj1
        Cj = Cj1
        j = j + 1.0
    }
    Sj
}