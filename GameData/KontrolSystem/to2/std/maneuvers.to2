/// Collection of helper functions to plan and execute standard orbital maneuvers

use { current_time, sleep, wait_until } from ksp::game
use { hud_text, YELLOW, RED } from ksp::console
use { ManeuverNode, Vessel, SITUATION_VACUUM } from ksp::vessel
use { Body, Orbit } from ksp::orbit
use core::math as math
use { look_dir_up, vec2, Vec3 } from ksp::math
use { ship_is_facing } from std::utils
use { reset_warp, phys_warp, warp_seconds } from std::warp
use { trigger_staging } from std::staging
use { solve_lambert } from std::lambert
use { amoeba_optimize_perturbation } from std::numerics::amoeba_optimize
use { anneal_optimize } from std::numerics::anneal_optimize
use { regula_falsi_solve } from std::numerics::regula_falsi_solve

/// Create a maneuver node to change to a (mostly) circular orbit at then next
/// apoapsis (from elliplic orbit) or periapsis (from hyperbolic orbit).
///
/// Will result in an error if maneuver nodes cannot be created 
/// (e.g. because command or tracking facility has not been sufficiently upgraded)
pub sync fn circularize_orbit(vessel : Vessel) -> Result<ManeuverNode, string> = {
    const orbit = vessel.orbit
    if(orbit.eccentricity < 1)
        circularize_orbit_at(vessel, orbit.next_apoapsis_time(current_time()))
    else
        circularize_orbit_at(vessel, orbit.next_periapsis_time(current_time()))
}

/// Create a maneuver node to change to a (mostly) circular orbit at a given universal time `UT`.
///
/// Will result in an error if maneuver nodes cannot be created 
/// (e.g. because command or tracking facility has not been sufficiently upgraded)
pub sync fn circularize_orbit_at(vessel : Vessel, UT : float) -> Result<ManeuverNode, string> = {
    const orbit = vessel.orbit
    const desired_velocity = circular_orbit_speed(orbit.reference_body, orbit.radius(UT)) * orbit.horizontal(UT)
    const actual_velocity = orbit.orbital_velocity(UT)

    vessel.maneuver.add_burn_vector(UT, desired_velocity - actual_velocity)
}

sync fn circular_orbit_speed(body : Body, radius : float) -> float = math::sqrt(body.grav_parameter / radius)

/// Create a maneuver node at `UT` to change the current orbit of `vessel` to an elliptic orbit with
/// given `apoapsis` and `periapsis` (above sea level).
///
/// Will result in an error if maneuver nodes cannot be created 
/// (e.g. because command or tracking facility has not been sufficiently upgraded)
pub sync fn ellipticize(vessel : Vessel, UT : float, periapsis : float, apoapsis : float) -> Result<ManeuverNode, string> = {
    const orbit = vessel.orbit
    const radius = orbit.radius(UT)

    const apoapsis_radius = math::max(0, apoapsis) + vessel.main_body.radius
    const periapsis_radius = math::max(0, periapsis) + vessel.main_body.radius
    const mu = vessel.main_body.grav_parameter

    const E = -mu / (periapsis_radius + apoapsis_radius) //total energy per unit mass of new orbit
    const L = math::sqrt(((math::pow(E * (apoapsis_radius - periapsis_radius), 2) - mu * mu) / (2 * E)).abs) //angular momentum per unit mass of new orbit
    const kineticE = E + mu / radius //kinetic energy (per unit mass) of new orbit at UT
    const horizontalV = L / radius   //horizontal velocity of new orbit at UT
    let verticalV = math::sqrt((2 * kineticE - horizontalV * horizontalV).abs) //vertical velocity of new orbit at UT

    const actual_velocity = orbit.orbital_velocity(UT)

    verticalV *= (orbit.up(UT) * actual_velocity).sign

    const desired_velocity = horizontalV * orbit.horizontal(UT) + verticalV * orbit.up(UT)

    vessel.maneuver.add_burn_vector(UT, desired_velocity - actual_velocity)
}

pub sync fn change_periapsis_burn(orbit : Orbit, UT : float, new_periapsis_radius : float) -> Vec3 = {
    const radius = orbit.radius(UT)
    new_periapsis_radius = math::clamp(new_periapsis_radius, 1, radius - 1)
    const raising = new_periapsis_radius > orbit.periapsis_radius
    const burn_direction = if(raising) orbit.horizontal(UT) else orbit.horizontal(UT)

    let min_delta_v = 0.0
    let max_delta_v = 0.0
    if(raising) {
        max_delta_v = 0.25
        while(orbit.perturbed_orbit(UT, max_delta_v * burn_direction).periapsis_radius < new_periapsis_radius) {
            min_delta_v = max_delta_v
            max_delta_v *= 2
            if(max_delta_v > 100000) break
        }
    } else {
        max_delta_v = (orbit.orbital_velocity(UT) * burn_direction).abs
    }

    const delta_v = regula_falsi_solve(fn(delta_v) -> orbit.perturbed_orbit(UT, delta_v * burn_direction).periapsis_radius - new_periapsis_radius, min_delta_v, max_delta_v, 0.1, 1000)

    delta_v * burn_direction
}

pub sync fn change_apoasis_burn(orbit : Orbit, UT : float, new_apoapsis_radius : float) -> Unit = {
    const radius = orbit.radius(UT)
    if(new_apoapsis_radius > 0) new_apoapsis_radius = math::max(new_apoapsis_radius, radius + 1)
    const raising = new_apoapsis_radius > orbit.apoapsis_radius
    const burn_direction = if(raising) orbit.horizontal(UT) else orbit.horizontal(UT)

    let min_delta_v = 0.0
    let max_delta_v = 0.0
    if(raising) {
        max_delta_v = 0.25
        while(orbit.perturbed_orbit(UT, max_delta_v * burn_direction).apoapsis_radius < new_apoapsis_radius) {
            min_delta_v = max_delta_v
            max_delta_v *= 2
            if(max_delta_v > 100000) break
        }
    } else {
        max_delta_v = (orbit.orbital_velocity(UT) * burn_direction).abs
    }

    const delta_v = regula_falsi_solve(fn(delta_v) -> orbit.perturbed_orbit(UT, delta_v * burn_direction).apoapsis_radius - new_apoapsis_radius, min_delta_v, max_delta_v, 0.1, 1000)

    delta_v * burn_direction
}

/// Create a maneuver node at `start_UT` to transfer from the current orbit of the `vessel` to
/// intercept an other `orbit` at `target_UT`
///
/// Will result in an error if maneuver nodes cannot be created 
/// (e.g. because command or tracking facility has not been sufficiently upgraded)
pub sync fn intercept_at(vessel : Vessel, start_UT : float, target : Orbit, target_UT : float, offset_distance : float) -> Result<ManeuverNode, string> = {
    const (start_velocity, _) = deltav_to_intercept_at(vessel.orbit, start_UT, target, target_UT, offset_distance)

    vessel.maneuver.add_burn_vector(start_UT, start_velocity)
}

/// Create a maneuver node to intercept a `target` orbit starting nearly at time `UT` with
/// a nearly transfer time of `TT`. `UT` and `TT` will be optimized for a minimal delta-v for
/// acceleration and deacceleration.
///
/// Will result in an error if maneuver nodes cannot be created 
/// (e.g. because command or tracking facility has not been sufficiently upgraded)
pub sync fn bi_impulsive_transfer_near(vessel : Vessel, target : Orbit, UT : float, TT : float) -> Result<ManeuverNode, string> = {
    const (x, y) = amoeba_optimize_perturbation(fn(start : float, tof : float) -> {
        const UT1 = UT + start
        const UT2 = UT1 + tof
        const (start_velocity, target_velocity) = deltav_to_intercept_at(vessel.orbit, UT1, target, UT2, 0)
        start_velocity.magnitude + target_velocity.magnitude
    }, vec2(0, TT), vec2(1, 1), 0.000001, 1000)?
    const burn_UT = UT + x

    intercept_at(vessel, burn_UT, target, burn_UT + y, 0)
}

/// Create a maneuver node to intercept a `target` orbit starting after `minUT`.
/// Actual starting and transfer time will be optimized for a minimal delta-v for
/// acceleration and deacceleration.
///
/// Will result in an error if maneuver nodes cannot be created 
/// (e.g. because command or tracking facility has not been sufficiently upgraded)
pub sync fn bi_impulsive_transfer(vessel : Vessel, target : Orbit, minUT : float) -> Result<ManeuverNode, string> = {
    const a = (vessel.orbit.semi_major_axis.abs + target.semi_major_axis.abs) / 2
    const max_start = 1.5 * vessel.orbit.synodic_period(target)
    const max_tof = math::PI * math::sqrt(a * a * a / vessel.main_body.grav_parameter)
    const (best, _) = anneal_optimize(fn(start : float, tof : float) -> {
        const UT1 = minUT + start
        const UT2 = UT1 + tof
        const (start_velocity, target_velocity) = deltav_to_intercept_at(vessel.orbit, UT1, target, UT2, 0)
        start_velocity.magnitude + target_velocity.magnitude
    }, vec2(0, 1), vec2(max_start, max_tof), 10000, 50, 10, .003)

    bi_impulsive_transfer_near(vessel, target, minUT + best.x, best.y)
}

/// Calculate required delta-v to intercept `target` orbit at time `target_UT` from `start` orbit at time `start_UT`.
/// `offset_distance` may be used to define a desired distance to the target.
pub sync fn deltav_to_intercept_at(start : Orbit, start_UT : float, target : Orbit, target_UT : float, offset_distance : float) -> (start_velocity : Vec3, target_velocity : Vec3) = {
    const start_rel_pos = start.relative_position(start_UT)
    let target_rel_pos = target.relative_position(target_UT)

    const start_orbit_velocity = start.orbital_velocity(start_UT)
    const target_orbit_velocity = target.orbital_velocity(target_UT)

    if(offset_distance != 0.0) target_rel_pos += offset_distance * target_orbit_velocity.cross(target_rel_pos).normalized
    let (v1, v2) = solve_lambert(start_rel_pos, target_rel_pos, target_UT - start_UT, start.reference_body.grav_parameter, false)
    const transfer_vi_clockwise = v1
    const transfer_vf_clockwise = v2
    (v1, v2) = solve_lambert(start_rel_pos, target_rel_pos, target_UT - start_UT, start.reference_body.grav_parameter, true)
    const transfer_vi_counter_clockwise = v1
    const transfer_vf_counter_clockwise = v2
    const total_clockwise = (target_orbit_velocity - transfer_vf_clockwise).magnitude + (transfer_vi_clockwise - start_orbit_velocity).magnitude
    const total_counter_clockwise = (target_orbit_velocity - transfer_vf_counter_clockwise).magnitude + (transfer_vi_counter_clockwise - start_orbit_velocity).magnitude

    if(total_clockwise < total_counter_clockwise)
        (target_velocity: target_orbit_velocity - transfer_vf_clockwise, start_velocity: transfer_vi_clockwise - start_orbit_velocity)
    else
        (target_velocity: target_orbit_velocity - transfer_vf_counter_clockwise, start_velocity: transfer_vi_counter_clockwise - start_orbit_velocity)
}

sync fn sample_ejection(body : Body, frame_x : Vec3, frame_y : Vec3, radius : float, exit_velocity : float) -> (orbit: Orbit, periapsis_velocity: float) = {
    const exit_energy = 0.5 * exit_velocity * exit_velocity - body.grav_parameter / body.SOI_radius
    const periapsis_velocity = math::sqrt(2 * (exit_energy + body.grav_parameter / radius))

    (orbit: body.create_orbit(frame_x * radius, frame_y * periapsis_velocity, 0), periapsis_velocity: periapsis_velocity)
}

/// Calculate the ideal ejection from a (nearly) circular orbit around a given `body`, `radius` and `normal` vector.
/// The resulting orbit is choosen so that the vessel will have a given `exit_velocity` on the SOI radius at time `UT`.
pub sync fn ideal_ejection(body : Body, UT : float, radius : float, normal : Vec3, exit_velocity : Vec3) -> Orbit = {
    // Create a more or less arbitrary frame of reference where exitVelocity points to sampleX
    const frame_x = exit_velocity.normalized
    const frame_z = frame_x.exclude_from(normal).normalized
    const frame_y = frame_z.cross(frame_x).normalized

    // Create a sample orbit in the plane perpendicular to sampleZ
    const (orbit, periapsis_velocity) = sample_ejection(body, frame_x, frame_y, radius, exit_velocity.magnitude)
    // Now we get the true anomaly of the exit point
    const exit_ta = orbit.true_anomaly_at_radius(body.SOI_radius)
    // ... the time it takes ot get from periapsis to exit point
    const dt = orbit.time_of_true_anomaly(exit_ta, 0)
    const sample_exit_velocity = orbit.orbital_velocity(dt)
    
    // By choice of the reference plane neither exitVelocity nor sampleExitVelocity
    // should have an z-component. So we just have to turn everything
    // around sampleY so that sampleExitVelocity points to sampleX as well.
    const angle = -math::atan2(frame_y * sample_exit_velocity, frame_x * sample_exit_velocity)

    const start_pos = radius * (math::cos(angle) * frame_x + math::sin(angle) * frame_y)
    const start_vel = periapsis_velocity * (math::cos(angle) * frame_y - math::sin(angle) * frame_x)

    body.create_orbit(start_pos, start_vel, UT - dt)
}

/// Execute the next planed maneuver node.
///
/// Will result in an error if there are no planed maneuver nodes.
pub fn exec_next_node(vessel : Vessel) -> Result<Unit, string> = {
    const node = vessel.maneuver.next_node()?

    vessel.actions.set_sas(false)
    vessel.actions.set_rcs(false)

    const dv0 = node.burn_vector
    const (burn_time, half_burn_time) = estimate_burn_time(vessel, dv0.magnitude, 1.0, 1.0)
    const steering_manager = vessel.manage_steering(fn() -> look_dir_up(node.burn_vector, vessel.orbit.relative_position(node.time)))
    const dv_min : Cell<float> = Cell(dv0.magnitude)
    const throttle_limit : Cell<(min: float, max: float)> = Cell((min: 0.0, max: 0.0))
    const throttle_manager = vessel.manage_throttle(fn() -> {
        const (min, max) = throttle_limit.value
        const dv = math::min(dv_min.value, node.burn_vector.magnitude)
        math::clamp(dv * vessel.mass / math::max(1.0, vessel.available_thrust), min, max)
    })

    // Align ship before warping
    let warped = false
    while(!ship_is_facing(vessel, steering_manager.current_direction.vector, 5, 0.5) || 
          (node.ETA <= half_burn_time && ship_is_facing(vessel, steering_manager.current_direction.vector, 20, 5))) {
        sleep(0.1)
        if(vessel.angular_velocity.magnitude < 0.01) vessel.actions.set_rcs(true)
        if(!warped) {
            warped = true
            phys_warp(1)
        }
    }
    if(warped) reset_warp()

    warp_seconds(node.ETA - half_burn_time - 10)    

    steering_manager.set_direction_provider(fn() -> look_dir_up(node.burn_vector, vessel.position - vessel.main_body.position))

    if(node.ETA - half_burn_time > 5) {
        phys_warp(1)
        wait_until(fn() -> node.ETA - half_burn_time <= 2)
        reset_warp()
    }
    wait_until(fn() -> node.ETA - half_burn_time <= 1)

    let almost_there = 0.0
    let choked = 0.0
    let warned = false

    while(dv_min.value >= 0.05) {
        const dv = node.burn_vector.magnitude

        dv_min.update(fn(m) -> math::min(m, dv))

        sleep(0.1)
        if(trigger_staging(vessel)) hud_text("Stage separation during navigation burn", 10, 36, 4, YELLOW)

        if(vessel.available_thrust > 0) {
            if(ship_is_facing(vessel, steering_manager.current_direction.vector, 20, 2)) {
                throttle_limit.set_value((min: 0.01, max: 1.0))
            } else {
                throttle_limit.set_value((min: 0.1, max: 0.1))
                vessel.actions.set_rcs(true)
            }
            if(dv0 * node.burn_vector < 0) break
            if(dv > dv_min.value + 0.1) break
            if(dv <= 0.2) {
                if(almost_there == 0.0) almost_there = current_time()
                if(current_time() - almost_there > 5) break
                if(dv <= 0.05) break
            }
            choked = 0.0
        } else {
            if(choked == 0.0) choked = current_time()
            if(!warned && current_time() - choked > 3) {
                warned = true
                hud_text("No acceleration", 10, 36, 4, YELLOW)
            }
            if(current_time() - choked > 30) {
                hud_text("No acceleration", 10, 36, 4, RED)
                return Err("No acceleration")
            }
        }
    }

    throttle_manager.release()
    steering_manager.release()

    node.remove()
}

/// Estimate the required burn time for a desired `delta_v` in vacuum.
///
/// * `stage_delay` is the assumed amount of seconds required for staging
/// * `throttle_limit` is a limit for the throttle to be considered
pub sync fn estimate_burn_time(vessel : Vessel, delta_v : float, stage_delay : float, throttle_limit : float) -> (burn_time: float, half_burn_time: float) = {
    let stage = vessel.stage.number + 1
    let dv_left = delta_v
    let half_dv_left = delta_v / 2
    let burn_time = 0.0
    let half_burn_time = 0.0
    let last_stage_burn_time = 0.0

    while(stage > 1) {
        stage -= 1

        const maybe_stage_info = vessel.stage_deltav(stage)

        if(!maybe_stage_info.defined) continue

        const stage_info = maybe_stage_info.value
        const stage_deltav = stage_info.get_deltav(SITUATION_VACUUM)
        const stage_thrust = stage_info.get_thrust(SITUATION_VACUUM)

        if(stage_deltav <= 0.0 || stage_thrust <= 0.0) {
            // This stage has to be skipped, i.e. it will be necessary to stage twice
            if (burn_time - last_stage_burn_time < stage_delay && stage != vessel.stage.number)
                burn_time += stage_delay - (burn_time - last_stage_burn_time)
            burn_time += stage_delay
            last_stage_burn_time = burn_time
            continue
        }
        const stage_burn_dv = math::min(stage_deltav, dv_left)
        dv_left -= stage_burn_dv
        const stage_burn_fraction = stage_burn_dv / stage_deltav

        // Delta-V is proportional to ln(m0 / m1) (where m0 is initial
        // mass and m1 is final mass). We need to know the final mass
        // after this stage burns (m1b):
        //      ln(m0 / m1) * stageBurnFraction = ln(m0 / m1b)
        //      exp(ln(m0 / m1) * stageBurnFraction) = m0 / m1b
        //      m1b = m0 / (exp(ln(m0 / m1) * stageBurnFraction))
        const stage_burn_final_mass = stage_info.start_mass / math::exp(math::log(stage_info.start_mass / stage_info.end_mass) * stage_burn_fraction)
        const stage_avg_accel = stage_thrust / ((stage_info.start_mass + stage_burn_final_mass) / 2) * throttle_limit

        half_burn_time += math::min(half_dv_left, stage_burn_dv) / stage_avg_accel
        half_dv_left = math::max(0, half_dv_left - stage_burn_dv)

        burn_time += stage_burn_dv / stage_avg_accel
    }

    (burn_time: burn_time, half_burn_time: half_burn_time)
}