/// Collection of helper functions to plan and execute standard orbital maneuvers

use { current_time, sleep, wait_until } from ksp::game
use { ManeuverNode, Vessel } from ksp::vessel
use { Body } from ksp::orbit
use { sqrt } from core::math
use { look_dir_up } from ksp::math
use { ship_is_facing } from std::utils
use { reset_warp, phys_warp, warp_seconds } from std::warp
use { trigger_staging } from std::staging

/// Create a maneuver node to change to a (mostly) circular orbit at then next
/// apoapsis (from elliplic orbit) or periapsis (from hyperbolic orbit).
///
/// Will result in an error if maneuver nodes cannot be created 
/// (e.g. because command or tracking facility has not been sufficiently upgraded)
pub sync fn circularize_orbit(vessel : Vessel) -> Result<ManeuverNode, string> = {
    const orbit = vessel.orbit
    if(orbit.eccentricity < 1)
        circularize_orbit_at(vessel, orbit.next_apoapsis_time(current_time()))
    else
        circularize_orbit_at(vessel, orbit.next_periapsis_time(current_time()))
}

/// Create a maneuver node to change to a (mostly) circular orbit at a given universal time `UT`.
///
/// Will result in an error if maneuver nodes cannot be created 
/// (e.g. because command or tracking facility has not been sufficiently upgraded)
pub sync fn circularize_orbit_at(vessel : Vessel, UT : float) -> Result<ManeuverNode, string> = {
    const orbit = vessel.orbit
    const desired_velocity = circular_orbit_speed(orbit.reference_body, orbit.radius(UT)) * orbit.horizontal(UT)
    const actual_velocity = orbit.orbital_velocity(UT)

    vessel.maneuver.add_burn_vector(UT, desired_velocity - actual_velocity)
}

sync fn circular_orbit_speed(body : Body, radius : float) -> float = sqrt(body.grav_parameter / radius)

/// Execute the next planed maneuver node.
///
/// Will result in an error if there are no planed maneuver nodes.
pub fn exec_next_node(vessel : Vessel) -> Result<Unit, string> = {
    const node = vessel.maneuver.next_node()?

    vessel.actions.set_sas(false)
    vessel.actions.set_rcs(false)

    const steer_dir = look_dir_up(node.burn_vector, vessel.orbit.relative_position(node.time))
    const burn_time = burn_time_for_dv(vessel, node.burn_vector.magnitude)
    const dt = burn_time / 2
    const steering_manager = vessel.manage_steering(fn() -> steer_dir)
    const throttle_manager = vessel.manage_throttle(fn() -> 0.0)

    // Align ship before warping
    let warped = false
    while(!ship_is_facing(vessel, steer_dir.vector, 1, 0.01) || 
          (node.ETA <= dt && ship_is_facing(vessel, steer_dir.vector, 20, 0.01))) {
        sleep(0.1)
        if(vessel.angular_velocity.magnitude < 0.01) vessel.actions.set_rcs(true)
        if(!warped) {
            warped = true
            phys_warp(1)
        }
    }
    if(warped) reset_warp()

    warp_seconds(node.ETA - dt - 10)    

    steering_manager.set_direction_provider(fn() -> look_dir_up(node.burn_vector, vessel.position - vessel.main_body.position))

    if(node.ETA - dt > 5) {
        phys_warp(1)
        wait_until(fn() -> node.ETA - dt <= 2)
        reset_warp()
    }
    wait_until(fn() -> node.ETA - dt <= 1)

    let dv_min = node.burn_vector.magnitude

    while(dv_min >= 0.05) {
        sleep(0.1)
        if(trigger_staging(vessel)) {

        }

    }

    throttle_manager.release()
    steering_manager.release()
}

sync fn burn_time_for_dv(vessel : Vessel, dv : float) -> float = vessel.mass * dv / vessel.max_thrust
