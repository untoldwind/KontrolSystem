/// Collection of helper functions to plan and execute standard orbital maneuvers

use { current_time } from ksp::game
use { Body, Orbit } from ksp::orbit
use core::math as math
use { vec2, Vec3 } from ksp::math
use { solve_lambert } from std::lambert
use { amoeba_optimize_perturbation } from std::numerics::amoeba_optimize
use { anneal_optimize } from std::numerics::anneal_optimize
use { regula_falsi_solve } from std::numerics::regula_falsi_solve

/// Calculate the required delta-v and time to change the given `orbit`
/// to a (mostly) circular orbit at the next apoapsis (if `orbit` is elliplic) 
/// or periapsis (if `orbit` is hyperbolic).
pub sync fn circularize_orbit(orbit : Orbit) -> (delta_v: Vec3, UT: float) = {
    const UT = if(orbit.eccentricity < 1) orbit.next_apoapsis_time() else orbit.next_periapsis_time()

    (delta_v: circularize_orbit_at(orbit, UT), UT: UT)
}

/// Calculate the required delta-v to change the given `orbit`
/// to a (mostly) circular orbit at a given universal time `UT`.
pub sync fn circularize_orbit_at(orbit : Orbit, UT : float) -> Vec3 = {
    const desired_velocity = circular_orbit_speed(orbit.reference_body, orbit.radius(UT)) * orbit.horizontal(UT)
    const actual_velocity = orbit.orbital_velocity(UT)

    desired_velocity - actual_velocity
}

sync fn circular_orbit_speed(body : Body, radius : float) -> float = math::sqrt(body.grav_parameter / radius)

/// Calculate the required delta-v to change the `apoapsis` and `periapsis` of the given `orbit` 
/// at time `UT`.
pub sync fn ellipticize(orbit : Orbit, UT : float, periapsis : float, apoapsis : float) -> Vec3 = {
    const radius = orbit.radius(UT)

    const apoapsis_radius = math::max(0, apoapsis) + orbit.reference_body.radius
    const periapsis_radius = math::max(0, periapsis) + orbit.reference_body.radius
    const mu = orbit.reference_body.grav_parameter

    const E = -mu / (periapsis_radius + apoapsis_radius) //total energy per unit mass of new orbit
    const L = math::sqrt(((math::pow(E * (apoapsis_radius - periapsis_radius), 2) - mu * mu) / (2 * E)).abs) //angular momentum per unit mass of new orbit
    const kineticE = E + mu / radius //kinetic energy (per unit mass) of new orbit at UT
    const horizontalV = L / radius   //horizontal velocity of new orbit at UT
    let verticalV = math::sqrt((2 * kineticE - horizontalV * horizontalV).abs) //vertical velocity of new orbit at UT

    const actual_velocity = orbit.orbital_velocity(UT)

    verticalV *= (orbit.up(UT) * actual_velocity).sign

    const desired_velocity = horizontalV * orbit.horizontal(UT) + verticalV * orbit.up(UT)

    desired_velocity - actual_velocity
}

/// Calculate the required delta-v to change the periapsis of an `orbit` 
/// to `new_periapsis_radius` at time `UT`
pub sync fn change_periapsis(orbit : Orbit, UT : float, new_periapsis_radius : float) -> Vec3 = {
    const radius = orbit.radius(UT)
    new_periapsis_radius = math::clamp(new_periapsis_radius, 1, radius - 1)
    const raising = new_periapsis_radius > orbit.periapsis_radius
    const burn_direction = if(raising) orbit.horizontal(UT) else orbit.horizontal(UT)

    let min_delta_v = 0.0
    let max_delta_v = 0.0
    if(raising) {
        max_delta_v = 0.25
        while(orbit.perturbed_orbit(UT, max_delta_v * burn_direction).periapsis_radius < new_periapsis_radius) {
            min_delta_v = max_delta_v
            max_delta_v *= 2
            if(max_delta_v > 100000) break
        }
    } else {
        max_delta_v = (orbit.orbital_velocity(UT) * burn_direction).abs
    }

    const delta_v = regula_falsi_solve(fn(delta_v) -> orbit.perturbed_orbit(UT, delta_v * burn_direction).periapsis_radius - new_periapsis_radius, min_delta_v, max_delta_v, 0.1, 1000)

    delta_v * burn_direction
}

/// Calculate the required delta-v to change the apoapsis of an `orbit` 
/// to `new_apoapsis_radiusyx` at time `UT`
pub sync fn change_apoasis(orbit : Orbit, UT : float, new_apoapsis_radius : float) -> Vec3 = {
    const radius = orbit.radius(UT)
    if(new_apoapsis_radius > 0) new_apoapsis_radius = math::max(new_apoapsis_radius, radius + 1)
    const raising = new_apoapsis_radius > orbit.apoapsis_radius
    const burn_direction = if(raising) orbit.horizontal(UT) else orbit.horizontal(UT)

    let min_delta_v = 0.0
    let max_delta_v = 0.0
    if(raising) {
        max_delta_v = 0.25
        while(orbit.perturbed_orbit(UT, max_delta_v * burn_direction).apoapsis_radius < new_apoapsis_radius) {
            min_delta_v = max_delta_v
            max_delta_v *= 2
            if(max_delta_v > 100000) break
        }
    } else {
        max_delta_v = (orbit.orbital_velocity(UT) * burn_direction).abs
    }

    const delta_v = regula_falsi_solve(fn(delta_v) -> orbit.perturbed_orbit(UT, delta_v * burn_direction).apoapsis_radius - new_apoapsis_radius, min_delta_v, max_delta_v, 0.1, 1000)

    delta_v * burn_direction
}

/// Calculate delta-v to intercept a `target` orbit starting nearly at time `UT` with
/// a nearly transfer time of `TT`. `UT` and `TT` will be optimized for a minimal delta-v for
/// acceleration and deacceleration.
pub sync fn bi_impulsive_transfer_near(start : Orbit, target : Orbit, UT : float, TT : float) -> Result<(delta_v: Vec3, UT: float), string> = {
    const (x, y) = amoeba_optimize_perturbation(fn(start_eta : float, tof : float) -> {
        const UT1 = UT + start_eta
        const UT2 = UT1 + tof
        const (start_velocity, target_velocity) = intercept_at(start, UT1, target, UT2)
        start_velocity.magnitude + target_velocity.magnitude
    }, vec2(0, TT), vec2(1, 1), 0.000001, 1000)?
    const burn_UT = UT + x
    const (start_velocity, _) = intercept_at(start, burn_UT, target, burn_UT + y)

    (delta_v: start_velocity, UT: burn_UT)
}

/// Calculate delta-v to intercept a `target` orbit starting after `minUT`.
/// Actual starting and transfer time will be optimized for a minimal delta-v for
/// acceleration and deacceleration.
///
/// Will result in an error if maneuver nodes cannot be created 
/// (e.g. because command or tracking facility has not been sufficiently upgraded)
pub sync fn bi_impulsive_transfer(start : Orbit, target : Orbit, minUT : float) -> Result<(delta_v: Vec3, UT: float), string> = {
    const a = (start.semi_major_axis.abs + target.semi_major_axis.abs) / 2
    const max_start = 1.5 * start.synodic_period(target)
    const max_tof = math::PI * math::sqrt(a * a * a / start.reference_body.grav_parameter)
    const (best, _) = anneal_optimize(fn(start_eta : float, tof : float) -> {
        const UT1 = minUT + start_eta
        const UT2 = UT1 + tof
        const (start_velocity, target_velocity) = intercept_at(start, UT1, target, UT2)
        start_velocity.magnitude + target_velocity.magnitude
    }, vec2(0, 1), vec2(max_start, max_tof), 10000)

    bi_impulsive_transfer_near(start, target, minUT + best.x, best.y)
}

/// Calculate required delta-v to intercept `target` orbit at time `target_UT` from `start` orbit at time `start_UT`.
/// `offset_distance` may be used to define a desired distance to the target.
pub sync fn intercept_at(start : Orbit, start_UT : float, target : Orbit, target_UT : float, offset_distance : float = 0) -> (start_velocity : Vec3, target_velocity : Vec3) = {
    const start_rel_pos = start.relative_position(start_UT)
    let target_rel_pos = target.relative_position(target_UT)

    const start_orbit_velocity = start.orbital_velocity(start_UT)
    const target_orbit_velocity = target.orbital_velocity(target_UT)

    if(offset_distance != 0.0) target_rel_pos += offset_distance * target_rel_pos.cross(target.orbit_normal).normalized
    const (transfer_vi_clockwise @ v1, transfer_vf_clockwise @ v2) = solve_lambert(start_rel_pos, target_rel_pos, target_UT - start_UT, start.reference_body.grav_parameter, false)
    const (transfer_vi_counter_clockwise @ v1, transfer_vf_counter_clockwise @ v2) = solve_lambert(start_rel_pos, target_rel_pos, target_UT - start_UT, start.reference_body.grav_parameter, true)
    const total_clockwise = (target_orbit_velocity - transfer_vf_clockwise).magnitude + (transfer_vi_clockwise - start_orbit_velocity).magnitude
    const total_counter_clockwise = (target_orbit_velocity - transfer_vf_counter_clockwise).magnitude + (transfer_vi_counter_clockwise - start_orbit_velocity).magnitude

    if(total_clockwise < total_counter_clockwise)
        (target_velocity: target_orbit_velocity - transfer_vf_clockwise, start_velocity: transfer_vi_clockwise - start_orbit_velocity)
    else
        (target_velocity: target_orbit_velocity - transfer_vf_counter_clockwise, start_velocity: transfer_vi_counter_clockwise - start_orbit_velocity)
}

sync fn sample_ejection(body : Body, frame_x : Vec3, frame_y : Vec3, radius : float, exit_velocity : float) -> (orbit: Orbit, periapsis_velocity: float) = {
    const exit_energy = 0.5 * exit_velocity * exit_velocity - body.grav_parameter / body.SOI_radius
    const periapsis_velocity = math::sqrt(2 * (exit_energy + body.grav_parameter / radius))

    (orbit: body.create_orbit(frame_x * radius, frame_y * periapsis_velocity, 0), periapsis_velocity: periapsis_velocity)
}

/// Calculate the ideal ejection from a (nearly) circular orbit around a given `body`, `radius` and `normal` vector.
/// The resulting orbit is choosen so that the vessel will have a given `exit_velocity` on the SOI radius at time `UT`.
pub sync fn ideal_ejection(body : Body, UT : float, radius : float, normal : Vec3, exit_velocity : Vec3) -> Orbit = {
    // Create a more or less arbitrary frame of reference where exitVelocity points to sampleX
    const frame_x = exit_velocity.normalized
    const frame_z = frame_x.exclude_from(normal).normalized
    const frame_y = frame_z.cross(frame_x).normalized

    // Create a sample orbit in the plane perpendicular to sampleZ
    const (orbit, periapsis_velocity) = sample_ejection(body, frame_x, frame_y, radius, exit_velocity.magnitude)
    // Now we get the true anomaly of the exit point
    const exit_ta = orbit.true_anomaly_at_radius(body.SOI_radius)
    // ... the time it takes ot get from periapsis to exit point
    const dt = orbit.time_of_true_anomaly(exit_ta, 0)
    const sample_exit_velocity = orbit.orbital_velocity(dt)
    
    // By choice of the reference plane neither exitVelocity nor sampleExitVelocity
    // should have an z-component. So we just have to turn everything
    // around sampleY so that sampleExitVelocity points to sampleX as well.
    const angle = -math::atan2(frame_y * sample_exit_velocity, frame_x * sample_exit_velocity)

    const start_pos = radius * (math::cos(angle) * frame_x + math::sin(angle) * frame_y)
    const start_vel = periapsis_velocity * (math::cos(angle) * frame_y - math::sin(angle) * frame_x)

    body.create_orbit(start_pos, start_vel, UT - dt)
}
